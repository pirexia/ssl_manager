from django.test import TestCase, Client
from django.contrib.auth import get_user_model
from certificates.models import CertificateEntry, Domain
from certificates.utils import generate_key_pair, serialize_key

User = get_user_model()

class OWASPPentest(TestCase):
    def setUp(self):
        self.client = Client()
        self.user_victim = User.objects.create_user(username='victim', password='Password123!')
        self.user_attacker = User.objects.create_user(username='attacker', password='Password123!')

        self.domain = Domain.objects.create(name='example.com')

        # Create a certificate for the victim
        self.cert_victim = CertificateEntry.objects.create(
            common_name='victim.example.com',
            domain=self.domain,
            csr_content='FAKE_CSR',
            private_key_content='FAKE_KEY',
            created_by=self.user_victim
        )

    def test_idor_certificate_access(self):
        """A01: Broken Access Control - IDOR check"""
        self.client.login(username='attacker', password='Password123!')

        # Attacker tries to view Victim's certificate
        url = f'/certificate/{self.cert_victim.id}/'
        response = self.client.get(url)

        # If IDOR is prevented, this should be 403 or 404 (or filtered out)
        if response.status_code == 200:
            print(f"WARNING: IDOR Vulnerability found! Attacker accessed certificate {self.cert_victim.id}")

        self.assertEqual(response.status_code, 403, "IDOR Vulnerability: Attacker can view victim's certificate")

    def test_injection_csr_generation(self):
        """A03: Injection - Test shell characters in inputs"""
        self.client.login(username='attacker', password='Password123!')

        # Try to inject shell command in subdomain
        payload = "test; cat /etc/passwd"

        response = self.client.post('/generate/', {
            'domain': self.domain.id,
            'subdomain': payload,
            'country': 'ES',
            # ... other fields
        })

        # If vulnerable to shell injection, this might execute or cause 500.
        # Since we use cryptography lib, it should just treat it as a string.
        # We check that it didn't crash (500) and ideally handled it safely.

        self.assertNotEqual(response.status_code, 500, "Injection payload caused server error")
